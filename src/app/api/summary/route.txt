// src/app/api/summary/route.js
import { NextResponse } from "next/server";
import OpenAI from "openai";
import yahooFinance from "yahoo-finance2";
import fs from "fs";
import path from "path";

// (Node.js ëŸ°íƒ€ì„ì„ ì‚¬ìš©í•˜ë„ë¡ ëª…ì‹œâ€”ì´ ì¤„ì„ ì¶”ê°€í•˜ì„¸ìš”)
export const runtime = "nodejs";

// â€ ë¶„ë¥˜ë³„ í‹°ì»¤ ì •ì˜
const TICKER_GROUPS = {
  "ğŸ‡ºğŸ‡¸ ë¯¸êµ­ì¦ì‹œ": { ë‹¤ìš°: "^DJI", "S&P500": "^GSPC", ë‚˜ìŠ¤ë‹¥: "^IXIC" },
  "ğŸŒ ê¸€ë¡œë²Œì§€ìˆ˜": { ë‹ˆì¼€ì´225: "^N225", FTSE100: "^FTSE", ì½”ìŠ¤í”¼: "^KS11" },
  "ğŸ’± í™˜ìœ¨": { "USD/KRW": "KRW=X", "USD/JPY": "JPY=X", "EUR/USD": "EURUSD=X" },
  "ğŸ›¢ï¸ ì›ìì¬": { WTIìœ : "CL=F", ê¸ˆ: "GC=F" },
  "â‚¿ ë””ì§€í„¸ìì‚°": { ë¹„íŠ¸ì½”ì¸: "BTC-USD", ì´ë”ë¦¬ì›€: "ETH-USD" },
};

// â OpenAI ì¸ìŠ¤í„´ìŠ¤
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// â‚ ìºì‹œ íŒŒì¼ ê²½ë¡œ
const CACHE_FILE = path.join(process.cwd(), "summaryCache.json");

export async function GET() {
  // 1) ìºì‹œ ë¶ˆëŸ¬ì˜¤ê¸°
  let cache = null;
  try {
    const raw = await fs.promises.readFile(CACHE_FILE, "utf-8");
    cache = JSON.parse(raw);
  } catch {
    // íŒŒì¼ ì—†ê±°ë‚˜ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë„˜ì–´ê°
  }

  const today = new Date().toISOString().slice(0, 10);
  if (cache && cache.timestamp.slice(0, 10) === today) {
    return NextResponse.json({ data: cache.data, summaries: cache.summaries });
  }

  // 2) ì˜¤ëŠ˜ ë°ì´í„° ìƒˆë¡œ ìˆ˜ì§‘
  const data = {};
  const summaries = {};

  for (const [groupName, tickers] of Object.entries(TICKER_GROUPS)) {
    // 2-1) ë“±ë½ë¥  ìˆ˜ì§‘
    const groupData = {};
    for (const [label, symbol] of Object.entries(tickers)) {
      try {
        const quote = await yahooFinance.quote(symbol);
        const ch = quote.regularMarketChangePercent;
        groupData[label] =
          typeof ch === "number" ? parseFloat(ch.toFixed(2)) : null;
      } catch {
        groupData[label] = null;
      }
    }
    data[groupName] = groupData;

    // 2-2) GPT ìš”ì•½
    const valid = Object.entries(groupData).filter(([, pct]) => pct != null);
    if (valid.length === 0) {
      summaries[groupName] = "ë°ì´í„°ê°€ ì—†ì–´ ìš”ì•½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
    } else {
      const lines = valid.map(([l, pct]) => `${l}: ${pct}%`).join("\n");
      const prompt = `${groupName} ì§€ìˆ˜ ë³€ë™ë¥ :\n${lines}\n\nìœ„ ë‚´ìš©ì„ ì „ë¬¸ê°€ ì‹œê°ìœ¼ë¡œ ê°„ê²°í•˜ê²Œ í•´ì„í•´ì¤˜.`;
      try {
        const resp = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            { role: "system", content: "ë‹¹ì‹ ì€ ê²½ì œ ì• ë„ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤." },
            { role: "user", content: prompt },
          ],
          temperature: 0.7,
        });
        summaries[groupName] = resp.choices[0].message.content.trim();
      } catch (e) {
        if (e.code === "insufficient_quota") {
          summaries[groupName] = "ìš”ì•½ ë¶ˆê°€: ì¿¼í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.";
        } else {
          console.error("GPT ìš”ì•½ ì—ëŸ¬:", e);
          summaries[groupName] = "ìš”ì•½ ì‹¤íŒ¨: ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
        }
      }
    }
  }

  // 3) ìºì‹œì— ì €ì¥
  try {
    const toCache = {
      timestamp: new Date().toISOString(),
      data,
      summaries,
    };
    await fs.promises.writeFile(
      CACHE_FILE,
      JSON.stringify(toCache),
      "utf-8"
    );
  } catch (e) {
    console.warn("ìºì‹œ íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨:", e);
  }

  return NextResponse.json({ data, summaries });
}
